syntax = "proto3";
package tendermint.types;

option go_package = "github.com/celestiaorg/celestia-core/proto/tendermint/types";

import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";
import "tendermint/crypto/proof.proto";
import "tendermint/version/types.proto";
import "tendermint/types/validator.proto";
import "tendermint/nmt/proof.proto";

// BlockIdFlag indicates which BlcokID the signature is for
enum BlockIDFlag {
  option (gogoproto.goproto_enum_stringer) = true;
  option (gogoproto.goproto_enum_prefix)   = false;

  BLOCK_ID_FLAG_UNKNOWN = 0 [(gogoproto.enumvalue_customname) = "BlockIDFlagUnknown"];
  BLOCK_ID_FLAG_ABSENT  = 1 [(gogoproto.enumvalue_customname) = "BlockIDFlagAbsent"];
  BLOCK_ID_FLAG_COMMIT  = 2 [(gogoproto.enumvalue_customname) = "BlockIDFlagCommit"];
  BLOCK_ID_FLAG_NIL     = 3 [(gogoproto.enumvalue_customname) = "BlockIDFlagNil"];
}

// SignedMsgType is a type of signed message in the consensus.
enum SignedMsgType {
  option (gogoproto.goproto_enum_stringer) = true;
  option (gogoproto.goproto_enum_prefix)   = false;

  SIGNED_MSG_TYPE_UNKNOWN = 0 [(gogoproto.enumvalue_customname) = "UnknownType"];
  // Votes
  SIGNED_MSG_TYPE_PREVOTE   = 1 [(gogoproto.enumvalue_customname) = "PrevoteType"];
  SIGNED_MSG_TYPE_PRECOMMIT = 2 [(gogoproto.enumvalue_customname) = "PrecommitType"];

  // Proposals
  SIGNED_MSG_TYPE_PROPOSAL = 32 [(gogoproto.enumvalue_customname) = "ProposalType"];
}

// PartsetHeader
message PartSetHeader {
  uint32 total = 1;
  bytes  hash  = 2;
}

message Part {
  uint32                  index = 1;
  bytes                   bytes = 2;
  tendermint.crypto.Proof proof = 3 [(gogoproto.nullable) = false];
}

// BlockID
message BlockID {
  bytes         hash            = 1;
  PartSetHeader part_set_header = 2 [(gogoproto.nullable) = false];
}

// --------------------------------

// Header defines the structure of a Tendermint block header.
message Header {
  // basic block info
  tendermint.version.Consensus version  = 1 [(gogoproto.nullable) = false];
  string                       chain_id = 2 [(gogoproto.customname) = "ChainID"];
  int64                        height   = 3;
  google.protobuf.Timestamp    time     = 4 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];

  // prev block info
  BlockID last_block_id = 5 [(gogoproto.nullable) = false];

  // hashes of block data
  bytes last_commit_hash = 6;  // commit from validators from the last block
  uint64 num_original_data_shares = 7;  // number of shares used in the original data square
  bytes data_hash        = 8;  // transactions

  // hashes from the app output from the prev block
  bytes validators_hash      = 9;   // validators for the current block
  bytes next_validators_hash = 10;   // validators for the next block
  bytes consensus_hash       = 11;  // consensus params for current block
  bytes app_hash             = 12;  // state after txs from the previous block
  bytes last_results_hash    = 13;  // root hash of all results from the txs from the previous block

  // consensus info
  bytes evidence_hash    = 14;  // evidence included in the block
  bytes proposer_address = 15;  // original proposer of the block
}

// Data contains the set of transactions included in the block
message Data {
  // Txs that will be applied by state @ block.Height+1.
  // NOTE: not all txs here are valid.  We're just agreeing on the order first.
  // This means that block.AppHash does not include these txs.
  repeated bytes         txs                      = 1;
  IntermediateStateRoots intermediate_state_roots = 2 [(gogoproto.nullable) = false];
  EvidenceList           evidence                 = 3 [(gogoproto.nullable) = false];
  Messages               messages                 = 4 [(gogoproto.nullable) = false];
}

message Evidence {
  oneof sum {
    DuplicateVoteEvidence     duplicate_vote_evidence      = 1;
    LightClientAttackEvidence light_client_attack_evidence = 2;
  }
}

// DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.
message DuplicateVoteEvidence {
  tendermint.types.Vote     vote_a             = 1;
  tendermint.types.Vote     vote_b             = 2;
  int64                     total_voting_power = 3;
  int64                     validator_power    = 4;
  google.protobuf.Timestamp timestamp          = 5 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
}

// LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.
message LightClientAttackEvidence {
  tendermint.types.LightBlock conflicting_block            = 1;
  int64                       common_height                = 2;
  repeated tendermint.types.Validator byzantine_validators = 3;
  int64                               total_voting_power   = 4;
  google.protobuf.Timestamp           timestamp            = 5 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
}

message EvidenceList {
  repeated Evidence evidence = 1 [(gogoproto.nullable) = false];
}

message IntermediateStateRoots {
  repeated bytes raw_roots_list = 1;
}

message Messages {
  repeated Message messages_list = 1;
}

message Message {
  bytes namespace_id = 1;
  bytes data         = 2;
}

// DataAvailabilityHeader contains the row and column roots of the erasure
// coded version of the data in Block.Data.
// Therefor the original Block.Data is arranged in a
// k × k matrix, which is then "extended" to a
// 2k × 2k matrix applying multiple times Reed-Solomon encoding.
// For details see Section 5.2: https://arxiv.org/abs/1809.09044
// or the LazyLedger specification:
// https://github.com/lazyledger/lazyledger-specs/blob/master/specs/data_structures.md#availabledataheader
// Note that currently we list row and column roots in separate fields
// (different from the spec).
message DataAvailabilityHeader {
  // RowRoot_j = root((M_{j,1} || M_{j,2} || ... || M_{j,2k} ))
  repeated bytes row_roots = 1;
  // ColumnRoot_j = root((M_{1,j} || M_{2,j} || ... || M_{2k,j} ))
  repeated bytes column_roots = 2;
}

// Vote represents a prevote, precommit, or commit vote from validators for
// consensus.
message Vote {
  SignedMsgType type     = 1;
  int64         height   = 2;
  int32         round    = 3;
  BlockID       block_id = 4
      [(gogoproto.nullable) = false, (gogoproto.customname) = "BlockID"];  // zero if vote is nil.
  google.protobuf.Timestamp timestamp = 5
      [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  bytes validator_address = 6;
  int32 validator_index   = 7;
  bytes signature         = 8;
}

// Commit contains the evidence that a block was committed by a set of validators.
message Commit {
  int64              height      = 1;
  int32              round       = 2;
  BlockID            block_id    = 3 [(gogoproto.nullable) = false, (gogoproto.customname) = "BlockID"];
  repeated CommitSig signatures  = 4 [(gogoproto.nullable) = false];
  bytes              header_hash = 5;
}

// CommitSig is a part of the Vote included in a Commit.
message CommitSig {
  BlockIDFlag               block_id_flag     = 1;
  bytes                     validator_address = 2;
  google.protobuf.Timestamp timestamp         = 3
      [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  bytes signature = 4;
}

message Proposal {
  SignedMsgType             type      = 1;
  int64                     height    = 2;
  int32                     round     = 3;
  int32                     pol_round = 4;
  BlockID                   block_id  = 5 [(gogoproto.customname) = "BlockID", (gogoproto.nullable) = false];
  google.protobuf.Timestamp timestamp = 6
      [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  bytes signature = 7;
}

message SignedHeader {
  Header header = 1;
  Commit commit = 2;
}

message LightBlock {
  SignedHeader                  signed_header = 1;
  tendermint.types.ValidatorSet validator_set = 2;
  DataAvailabilityHeader    da_header = 3 [(gogoproto.customname) = "DAHeader"];
}

message BlockMeta {
  BlockID block_id   = 1 [(gogoproto.customname) = "BlockID", (gogoproto.nullable) = false];
  int64   block_size = 2;
  Header  header     = 3 [(gogoproto.nullable) = false];
  int64   num_txs    = 4;
  DataAvailabilityHeader da_header = 5;
}

// TxProof represents a Merkle proof of the presence of a transaction in the Merkle tree.
message TxProof {
  bytes                   root_hash = 1;
  bytes                   data      = 2;
  tendermint.crypto.Proof proof     = 3;
}

// Protobuf definitions for the contents of state elements

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#account
// AccountStatus
enum AccountStatus {
    None = 0;
    DelegationBonded = 1;
    DelegationUnbonding = 2;
    ValidatorQueued = 3;
    ValidatorBonded = 4;
    ValidatorUnbonding = 5;
    ValidatorUnbonded = 6;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#periodentry
message PeriodEntry {
  // Rewards per unit of voting power accumulated so far, in 1u
  uint64 rewardRate = 1;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#decimal
message Decimal {
  // Rational numerator
  uint64 numerator = 1;
  // Rational denominator
  uint64 denominator = 2;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#messagepaid
message MessagePaid {
  // Share index (in row-major order) of first share paid for (inclusive)
  uint64 start = 1;
  // Share index (in row-major order) of last share paid for (inclusive)
  uint64 finish = 2;
  // Next transaction ID in the list
  // 32-byte hash
  bytes next = 3;
}

// Protobuf definitions for the state elements

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#account
message Account {
  // Coin balance
  uint64 balance = 1;
  // Account nonce. Every outgoing transaction from this account increments the nonce.
  uint64 nonce = 2;
  // Validator or delegation status of this account
  AccountStatus status = 3;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#delegation
message Delegation {
  // The validator being delegating to
  // 32-bytes
  bytes validator = 1;
  // Delegated stake, in 4u
  uint64 stakedBalance = 2;
  // Entry when delegation began
  PeriodEntry beginEntry = 3;
   // Entry when delegation ended (i.e. began unbonding)
  PeriodEntry endEntry = 4;
   // Block height delegation began unbonding
  int64 unbondingHeight = 5;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#validator
message StateValidator {
   // Validator's commission rewards, in 1u
   uint64 commissionRewards = 1;
   // Commission rate
   Decimal commissionRate = 2;
   // Number of accounts delegating to the validator
   uint32 delegatedCount = 3;
   // Total voting power as staked balance + delegated stake, in 4u
   uint64 votingPower = 4;
   // Rewards collected so far this period, in 1u
   uint64 pendingRewards = 5;
   // Latest entry, used for calculating reward distribution
   PeriodEntry latestEntry = 6;
   // Block height validator began unbonding
   int64 unbondingHeight = 7;
   // If this validator has been slashed or not
   bool isSlashed = 8;
   // Rate at which this validator has been slashed
   // slashRate should be zero if isSlashed is false.
   Decimal slashRate = 9;
   // Next validator in the queue. Zero if this validator is not in the queue
   // 32-bytes
   bytes next = 10;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#activevalidatorcount
message ActiveValidatorCount {
  // Number of active validators
  uint32 numValidators = 1;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#activevotingpower
message ActiveVotingPower {
  // Active voting power
  uint64 votingPower = 1;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#proposerblockreward
message ProposerBlockReward {
  // Total block reward (subsidy + fees) in current block so far. Reset each block
  uint64 reward = 1;
}


// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#proposerinitialvotingpower
message ProposerInitialVotingPower {
  // Voting power of the proposer at the start of each block. Set each block
  uint64 votingPower = 1;
}


// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#validatorqueuehead
message ValidatorQueueHead {
  // Address of inactive validator at the head of the validator queue
  // 32-bytes
  bytes head = 1;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#messagepaidhead
message MessagePaidHead {
  // Transaction hash at the head of the list (has the smallest start index)
  // 32-byte hash
  bytes head = 1;
}

//Protobuf definitions for the contents of fraud proofs

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/data_structures.md#namespacemerkletreeinclusionproof
message NamespaceMerkleTreeInclusionProof {
  // sibling hash values, ordered starting from the leaf's neighbor
  // array of 32-byte hashes
  repeated bytes siblingValues = 1;
  // sibling min namespace IDs
  // array of NAMESPACE_ID_BYTES-bytes
  repeated bytes siblingMins = 2;
  // sibling max namespace IDs
  // array of NAMESPACE_ID_BYTES-bytes
  repeated bytes siblingMaxes = 3;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/data_structures.md#sparsemerkletreeinclusionproof
message SparseMerkleTreeInclusionProof {
  // depth of the leaf node, must be <= 256
  // The root node is at depth 0.
  uint32 depth = 1;
  // sibling hash values, ordered starting from the leaf's neighbor
  // array of 32-byte hashes
  repeated bytes siblings = 2;
  // bitfield of explicitly included sibling hashes
  // 32-byte
  bytes includedSiblings = 3;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/data_structures.md#share
message Share {
  // namespace ID of the share
  // NAMESPACE_ID_BYTES-bytes
  bytes namespaceID = 1;
  // raw share data
  // SHARE_SIZE-bytes
  bytes rawData = 2;
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/data_structures.md#stateelement
message StateElement {
  // key of the state element
  // 32-bytes
  bytes key = 1;
  // key of the state element
  // value can be of different types depending on the state element.
  // There exists a unique protobuf for different state elements.
  oneof value {
    Account account = 2;
    Delegation delegation = 3;
    StateValidator stateValidator = 4;
    ActiveValidatorCount activeValidatorCount = 5;
    ActiveVotingPower activeVotingPower = 6;
    ProposerBlockReward proposerBlockReward = 7;
    ProposerInitialVotingPower proposerInitialVotingPower = 8;
    ValidatorQueueHead validatorQueueHead = 9;
    MessagePaid messagePaid = 10;
    MessagePaidHead messagePaidHead = 11;
  }
}

// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#shareproof
message ShareProof {
  // the share
  Share share = 1;
  // the Merkle proof of the share in the offending row or column root
  tendermint.nmt.Proof proof = 2;
  // a Boolean indicating if the Merkle proof is from a row root or column root; false if it is a row root
  bool isCol = 3;
  // the index of the share in the offending row or column
  uint64 position = 4;
}

//Protobuf definitions for the fraud proofs

// ANCHOR: BadEncodingFraudProof
// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#badencodingfraudproof
message BadEncodingFraudProof {
  // height of the block with the offending row or column
  int64 height = 1;
  // the available shares in the offending row or column and their Merkle proofs
  // array of ShareProofs
  repeated ShareProof shareProofs = 2;
  // a Boolean indicating if it is an offending row or column; false if it is a row
  bool isCol = 3;
  // the index of the offending row or column in the square
  uint64 position = 4;
}
// ANCHOR_END: BadEncodingFraudProof

// ANCHOR: StateFraudProof
// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#statefraudproof
message StateFraudProof {
  // height of the block with the intermediate state roots
  // Subtracting one from height gives the height of the block with the transactions.
  int64 height = 1;
  // shares containing the transactions and their Merkle proofs
  // isCol within the ShareProof must be false.
  // array of ShareProofs
  repeated ShareProof transactionShareProofs = 2;
  // shares containing the intermediate state roots and their Merkle proofs
  // isCol within the ShareProof must be false.
  // array of ShareProofs
  repeated ShareProof isrShareProofs = 3;
  // index for connecting the WrappedIntermediateStateRoot and WrappedTransaction after shares are parsed
  uint64 index = 4;
  // state elements that were changed by the transactions
  // array of StateElements
  repeated StateElement intermediateStateElements = 5;
  // sparse Merkle tree inclusion proofs for the state elements
  // array of SparseMerkleTreeInclusionProofs
  repeated SparseMerkleTreeInclusionProof stateInclusionProofs = 6;
}